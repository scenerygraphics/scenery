#version 450
#define USE_PRINTF 1
#define DOUBLE_BUFFER 1
#define INT_DEPTHS 0

#extension GL_EXT_debug_printf : disable
#if USE_PRINTF
#extension GL_EXT_debug_printf : enable
#endif

layout(set = 0, binding = 0) uniform VRParameters {
    mat4 projectionMatrices[2];
    mat4 inverseProjectionMatrices[2];
    mat4 headShift;
    float IPD;
    int stereoEnabled;
} vrParameters;

const int MAX_NUM_LIGHTS = 1024;

layout(set = 1, binding = 0) uniform LightParameters {
    mat4 ViewMatrices[2];
    mat4 InverseViewMatrices[2];
    mat4 ProjectionMatrix;
    mat4 InverseProjectionMatrix;
    vec3 CamPosition;
};

layout(set = 5, binding = 0) uniform ShaderProperties {
    mat4 ProjectionOriginal;
    mat4 invProjectionOriginal;
    mat4 ViewOriginal;
    mat4 ViewOriginal2;
    mat4 invViewOriginal;
    mat4 invViewOriginal2;
    bool useSecondBuffer;
    mat4 invModel;
    vec3 volumeDims;
    float nw;
    int vdiWidth;
    int vdiHeight;
    int totalGeneratedSupsegs;
    float downImage;
    bool do_subsample;
    int max_samples;
    float sampling_factor;
    bool skip_empty;
};

layout(push_constant) uniform currentEye_t {
    int eye;
} currentEye;

layout (local_size_x = 16, local_size_y = 16) in;
layout(set = 2, binding = 0, rgba32f) uniform readonly image3D InputVDI;
layout(set = 3, binding = 0, rgba8) uniform image2D OutputViewport;
#if INT_DEPTHS
layout (set = 4, binding = 0, rg16ui) uniform readonly uimage3D DepthVDI;
#else
layout (set = 4, binding = 0, rg32f) uniform readonly image3D DepthVDI;
#endif
layout (set = 6, binding = 0, r32ui) uniform readonly uimage3D AccelerationGrid;
#if DOUBLE_BUFFER
layout(set = 7, binding = 0, rgba32f) uniform readonly image3D InputVDI2;
#if INT_DEPTHS
layout (set = 8, binding = 0, rg16ui) uniform readonly uimage3D DepthVDI2;
#else
layout (set = 8, binding = 0, rg32f) uniform readonly image3D DepthVDI2;
#endif
layout (set = 9, binding = 0, r32ui) uniform readonly uimage3D AccelerationGrid2;
#endif
ivec2 debug_pixel = ivec2(720, 360);

#define GET_SUPERSEGMENT_COLOR(list, index, secondBuffer) secondBuffer? imageLoad(InputVDI2, ivec3(list.x, list.y, index)) : imageLoad(InputVDI, ivec3(list.x, list.y, index))

#define GET_SUPERSEGMENT_FRONT(list, index, secondBuffer) secondBuffer? imageLoad(DepthVDI2, ivec3(list.x, list.y, index)).x : imageLoad(DepthVDI, ivec3(list.x, list.y, index)).x
#define GET_SUPERSEGMENT_BACK(list, index, secondBuffer) secondBuffer? imageLoad(DepthVDI2, ivec3(list.x, list.y, index)).y : imageLoad(DepthVDI, ivec3(list.x, list.y, index)).y

int getNumberOfSupersegments(bool secondBuffer) {
    if(secondBuffer) {
        return imageSize(InputVDI2).z;
    } else {
        return imageSize(InputVDI).z;
    }
}

float adjustOpacity(float a, float modifiedStepLength) {
    float b = pow((1.0 - a), modifiedStepLength);
    return 1.0 - b;
}

struct rayProperties {
    ivec2 coords;
    vec4 NDC_front;
    vec4 NDC_back;
    vec4 wfront;
    vec4 wback;
};

mat4 pv_orig, ivp_orig;
int windowWidth, windowHeight;

rayProperties originalRay; // the ray (i.e. list) from the original VDI that is currently being intersected
rayProperties newRay; // the ray from the new viewpoint that this kernel invocation is traversing

vec4 front_orig; // the start point of newRay in the perspective space of the original viewpoint
vec4 back_orig; // the end point of newRay in the perspective space of the original viewpoint

float orig_tnear;
float orig_tfar;

float ndc_to_w(vec2 uv, float n_depth)
{
    //TODO: possible optimization by converting only the z coordinate to view space and comparing with f and n
    if(n_depth >= 1.0) {
        return 1.0;
    }

    if(n_depth <= -1.0) {
        return 0.0;
    }

    vec4 ndc_start = vec4(uv, n_depth, 1.0);

    vec4 w_start = ivp_orig * ndc_start;
    w_start *= 1.0 / w_start.w;

    float w_depth = distance(w_start, originalRay.wfront) / distance(originalRay.wfront, originalRay.wback);

    return w_depth;
}

float w_to_ndc(float w_step)
{
    vec4 wpos = mix(originalRay.wfront, originalRay.wback, w_step);

    vec4 n_pos = pv_orig * wpos;
    n_pos *= 1.0 / n_pos.w;

    return n_pos.z;
}

// intersect ray with a box
// http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm
void intersectBox( vec3 r_o, vec3 r_d, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar){
    // compute intersection of ray with all six bbox planes
    vec3 invR = 1 / r_d; // TODO: shouldn't r_d be a unit vector? And what if any component is 0?
    vec3 tbot = invR * ( boxmin - r_o );
    vec3 ttop = invR * ( boxmax - r_o );

    // re-order intersections to find smallest and largest on each axis
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    // find the largest tmin and the smallest tmax
    tnear = max( max( tmin.x, tmin.y ), max( tmin.x, tmin.z ) );
    tfar = min( min( tmax.x, tmax.y ), min( tmax.x, tmax.z ) );
}

void intersectBoundingBox_x_11_x_( vec4 wfront, vec4 wback, out float tnear, out float tfar ){
    vec4 mfront = invModel * wfront;
    vec4 mback = invModel * wback;
    intersectBox( mfront.xyz, (mback - mfront).xyz, vec3( 0, 0, 0 ), volumeDims, tnear, tfar);
}

ivec2 prevList = ivec2(-1);
int prevIndex = -1;

int maxSupersegments;

ivec3 num_cells;

float near_plane = 0.1; //TODO: get from the CPU
float far_plane = 20.0;

float A = -1 * ((far_plane) / (far_plane - near_plane));
float B = -1 * ((far_plane * near_plane) / (far_plane - near_plane));

float z_to_view(float z_n) {
    float z_v = -1 * (B / (A + z_n));
    return z_v;
}

float z_to_ndc(float z_v) {
    float z_n = -1 * ((A * z_v + B)/z_v);
    return z_n;
}

int findZInterval_ndc(float z_val) {
    float dist_from_front = z_val - (-1);
    int interval_num = int(floor(dist_from_front / (2.0 / num_cells.z)));
    return interval_num;
}

int findZInterval_view(float z_ndc) {
    float z_view = z_to_view(z_ndc);
    float dist_from_front = abs(z_view - (-1 * near_plane));
    int interval_num = int(floor(dist_from_front / ((far_plane - near_plane) / num_cells.z)));
    return interval_num;
}

void findListNumber(vec4 wpos, out ivec2 listNum, out vec4 NDC_orig) {
    //For this sample point, calculate ray number from original VDI
    NDC_orig = pv_orig * wpos;
    NDC_orig *= 1/NDC_orig.w; //TODO: check
    if(NDC_orig.x < -1 || NDC_orig.x > 1 || NDC_orig.y < -1 || NDC_orig.y > 1 || NDC_orig.z < -1 || NDC_orig.z > 1)
    {
        listNum = ivec2(-1, -1);
        NDC_orig = vec4(-1.);
        return; // This sample point is not in the original viewport and therefore cannot be in the VDI
    }
    vec2 tex_orig = (NDC_orig.xy + 1) / 2.0;
    listNum.x = int(round(tex_orig.x * vdiWidth)); //TODO: verify that this is correct. Maybe floor makes more sense?
    listNum.y = int(round(tex_orig.y * vdiHeight)); //TODO: verify that this is correct. Maybe floor makes more sense?
}

float getSupsegFront(ivec2 theList, int index) {

    #if INT_DEPTHS
    #if DOUBLE_BUFFER
    uint front_index = GET_SUPERSEGMENT_FRONT(theList, index, useSecondBuffer);
    #else
    uint front_index = GET_SUPERSEGMENT_FRONT(theList, index, false);
    #endif
    if(front_index == 0 && index != 0) {
        return 0.0;
    }
    float step = orig_tnear + nw * front_index;
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Searching for front depth of: (%d, %d), %d. Found jump num: %u, therefore returning: %f. orig_tnear: %f, nw: %f", theList, index, front_index, step, orig_tnear, nw);
            }
            #endif
    return step;
    #else

    #if DOUBLE_BUFFER
    float front = GET_SUPERSEGMENT_FRONT(theList, index, useSecondBuffer);
    #else
    float front = GET_SUPERSEGMENT_FRONT(theList, index, false);
    #endif
    return front;
    #endif
}

float getSupsegBack(ivec2 theList, int index) {

    #if INT_DEPTHS
    #if DOUBLE_BUFFER
    uint back_index = GET_SUPERSEGMENT_BACK(theList, index, useSecondBuffer);
    #else
    uint back_index = GET_SUPERSEGMENT_BACK(theList, index, false);
    #endif
    if(back_index == 0 && index != 0) {
        return 0.0;
    }
    float step = orig_tnear + nw * back_index;
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Searching for back depth of: (%d, %d), %d. Found jump num: %u, therefore returning: %f. orig_tnear: %f, nw: %f", theList, index, back_index, step, orig_tnear, nw);
            }
            #endif
    return step;
    #else
    #if DOUBLE_BUFFER
    float back = GET_SUPERSEGMENT_BACK(theList, index, useSecondBuffer);
    #else
    float back = GET_SUPERSEGMENT_BACK(theList, index, false);
    #endif
    return back;
    #endif
}

float getPrecedingDepth(ivec2 theList, int index) {
    float ret = getSupsegBack(theList, index - 1);

    if(index >= 1) {
        return ret;
    } else {
        return -50000.; // -inf
    }
}

void binSearch(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    int low = start;
    int high = end;

    while(low <= high) {
        index = (low + high)/2;
        depthEnd = getSupsegBack(theList, index);
        if(depthEnd == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }
        if(depthEnd < dist_to_orig) { //this supersegment is behind the sample point
            low = index + 1;
        } else {
            float prevEnd = getPrecedingDepth(theList, index);

            if(prevEnd < dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                high = index - 1;
            }
        }
    }
}

void binSearch2(ivec2 theList, float dist_to_orig, int start, int end, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    int low = start;
    int high = end;
    while(low <= high) {
        index = (low + high)/2;
        depthStart = getSupsegFront(theList, index);
        if(depthStart == 0.0) { //TODO: improve empty detection mechanism
            //this supersegment has not been filled
            high = index - 1;
            continue;
        }
        if(depthStart > dist_to_orig) { //this supersegment is behind the sample point
            high = index - 1;
        } else {
            float nextStart = (index<maxSupersegments-1)?getSupsegFront(theList, index+1):5000.;
            if(nextStart==0.0){
                supseg_found=true;
                break;
            }
            if(nextStart > dist_to_orig) {
                // this is the supersegment
                supseg_found = true;
                break;
            } else {
                low = index + 1;
            }
        }
    }
}

void nextSupersegmentInList(ivec2 theList, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    if(dotPositive) {
        if(prevIndex == maxSupersegments - 1) {
            return;
        }
        index = prevIndex + 1;
        depthStart = getSupsegFront(theList, index);
        if(depthStart < exit_distance && depthStart != 0) {
            // we have found our next supseg
            supseg_found = true;
            depthEnd = getSupsegBack(theList, index);
        }
    } else {
        if(prevIndex == 0) {
            return;
        }
        index = prevIndex - 1;
        depthEnd = getSupsegBack(theList, index);
        if(depthEnd > exit_distance) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel){
                debugPrintfEXT("found next supersegment\n");
            }
                #endif
            supseg_found = true;
            depthStart = getSupsegFront(theList, index);
        }
    }
}

vec4 u, dir;

//TODO: this function is probably not needed and the call in traverseSubsample should be replaced with opt_seeded version
void findFirstSupseg(ivec2 theList, float dist_to_orig, float exit_distance, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    if(prevIndex == -1) {
        binSearch(theList, dist_to_orig, 0, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
    } else {

        if(getSupsegBack(theList, prevIndex) == 0 || getSupsegBack(theList, prevIndex) >= dist_to_orig) {
            //the supersegment we are searching for, if present, lies on the left of prevIndex
            //we can check the end-point of the preceding supersegment
            if((getPrecedingDepth(theList, prevIndex) < dist_to_orig) ) { //check if prevIndex is a candidate
                if(getSupsegBack(theList, prevIndex) != 0) { // if prevIndex was filled, it is the supseg we are searching for
                    supseg_found = true;
                    index = prevIndex;
                    depthEnd = getSupsegBack(theList, index);

                }
                else {
                    binSearch(theList, dist_to_orig, 0, prevIndex - 1, supseg_found, index, depthStart, depthEnd);
                }
                // why do this?
            }
        } else {
            if(prevIndex < (maxSupersegments - 1)) {
                if(getSupsegBack(theList, prevIndex + 1) >= dist_to_orig) {
                    supseg_found = true;
                    index = prevIndex + 1;
                    depthEnd = getSupsegBack(theList, index);
                } else if(prevIndex < (maxSupersegments - 2)) {
                    binSearch(theList, dist_to_orig, prevIndex + 2, maxSupersegments - 1, supseg_found, index, depthStart, depthEnd);
                }
            }
        }

    }

    depthStart = getSupsegFront(theList, index);

    if(depthStart > exit_distance) {
        supseg_found = false;
    }

}

void findFirstSupseg_opt_seeded(ivec2 theList, float dist_to_orig, float exit_distance, bool dotPositive, out bool supseg_found, out int index, out float depthStart, out float depthEnd) {
    supseg_found = false;
    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("prevIdx: %d\n", prevIndex);
    }
        #endif
    int bin_search_end = -1;
    int bin_search_start = -1;
    bool condition;
    condition = prevIndex < 0;
    if(condition){
        bin_search_end = maxSupersegments - 1;
        bin_search_start = 0;
    } else {
        float sides[2];
        if(!dotPositive){
            sides[0]=getSupsegFront(theList, prevIndex);
            sides[1]=getSupsegFront(theList, prevIndex+1);
            sides[1]=((sides[1] == 0) || (prevIndex<=maxSupersegments-2))?5000:sides[1];
            sides[0] = (sides[0]==0)?-5000:sides[0];
        } else{
            sides[1] = getSupsegBack(theList, prevIndex);
            sides[0] = getSupsegBack(theList, prevIndex - 1);
            sides[0] = ((prevIndex - 1) >= 0)?sides[0]:-5000;
            sides[1] = (sides[1] == 0)?5000:sides[1];
        }
        int interval = int(sides[1]>=dist_to_orig)+int(sides[0]>=dist_to_orig);
        if(interval==2){
            bin_search_start = 0;
            bin_search_end=prevIndex-1;
        }else if(interval ==0){
            bin_search_start = prevIndex+1;
            bin_search_end=maxSupersegments-1;
        }else{
            if(sides[1]<4995){
                supseg_found=true;
                index=prevIndex;
                depthStart=sides[1];
            }else{
                bin_search_start=prevIndex-int(dotPositive);
                bin_search_end=maxSupersegments-1;
            }
        }
    }
        #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("trying to binsearch theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
    }
        #endif
    if (bin_search_end != -1)
    {
        if(!dotPositive){
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("binsearch2 theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
            }
                #endif
            binSearch2(theList, dist_to_orig, bin_search_start, bin_search_end, supseg_found, index, depthStart, depthEnd);
            depthEnd = getSupsegBack(theList, index);
            if(depthEnd<exit_distance) { supseg_found=false; }
            return;
        }else{
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("binsearch theList: (%d, %d), dist_to_orig%f, bin_search_start%d, bin_search_end%d, maxSupersegments%d\n",theList, dist_to_orig, bin_search_start, bin_search_end, maxSupersegments);
            }
                #endif
            binSearch(theList, dist_to_orig, bin_search_start, bin_search_end, supseg_found, index, depthStart, depthEnd);
            depthStart = getSupsegFront(theList, index);
            if(depthStart>exit_distance) { supseg_found=false; }
            return;
        }
    }
    depthEnd = getSupsegBack(theList, index);
    depthStart = getSupsegFront(theList, index);
    if((dotPositive && depthStart > exit_distance) || (!dotPositive && depthEnd<exit_distance)) {
        supseg_found = false;
    }
}

void findSupsegsInList(ivec2 theList, vec4 start_point, vec4 end_point, inout vec4 accumulatedColor) {

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Intersecting list: (%d, %d). Start pt: (%f, %f, %f) and End pt: (%f, %f, %f)\n", theList,
        start_point.xyz, end_point.xyz);
    }
        #endif

    //TODO: see whether the below is required

    bool first_empty = false;

    #if INT_DEPTHS

    #if DOUBLE_BUFFER
    uint check = GET_SUPERSEGMENT_FRONT(theList, 0, useSecondBuffer);
    #else
    uint check = GET_SUPERSEGMENT_FRONT(theList, 0, false);
    #endif

    if(check == 0) {
        first_empty = true;
    }

    #else

    #if DOUBLE_BUFFER
    float check = GET_SUPERSEGMENT_FRONT(theList, 0, useSecondBuffer);
    #else
    float check = GET_SUPERSEGMENT_FRONT(theList, 0, false);
    #endif

    if(check == 0) {
        first_empty = true;
    }
    #endif

    if(first_empty) {
        //the first supersegment is empty, so empty list
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Returning because first element was 0. The list no. was: (%d, %d)", theList);
        }
            #endif
        return;
    }

    float ndc_x = float(theList.x) / vdiWidth * 2.0 - 1.0;
    float ndc_y = float(theList.y) / vdiHeight * 2.0 - 1.0;

    originalRay.coords = theList;
    originalRay.NDC_front = vec4( ndc_x, ndc_y, -1, 1 );
    originalRay.NDC_back = vec4( ndc_x, ndc_y, 1, 1 );

    originalRay.wfront = ivp_orig * originalRay.NDC_front;
    originalRay.wfront *= 1.0 / originalRay.wfront.w;

    originalRay.wback = ivp_orig * originalRay.NDC_back;
    originalRay.wback *= 1.0 / originalRay.wback.w;

    orig_tnear = 1, orig_tfar = 0;
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( originalRay.wfront, originalRay.wback, n, f );

    if ( n < f )
    {
        orig_tnear = min( orig_tnear, max( 0, n ) );
        orig_tfar = max( orig_tfar, f );
        vis = true;
    }

    float dist_to_orig_n = start_point.z;

    float exit_distance_n = end_point.z;

    bool dotPositive;
    //TODO: check for dir.z?
    dotPositive = (dir.z>=0) ? true: false;

    #if INT_DEPTHS
    float dist_to_orig_w = ndc_to_w(vec2(ndc_x, ndc_y), dist_to_orig_n);
    float exit_distance_w = ndc_to_w(vec2(ndc_x, ndc_y), exit_distance_n);

    float dist_to_orig = dist_to_orig_w;
    float exit_distance = exit_distance_w;
    #else
    float dist_to_orig = dist_to_orig_n;
    float exit_distance = exit_distance_n;
    #endif

    bool supseg_found = false;

    bool firstIteration = true;

    do {
        float depthStart, depthEnd;
        int index;

        if(firstIteration) {
            findFirstSupseg_opt_seeded(theList, dist_to_orig, exit_distance,dotPositive, supseg_found, index, depthStart, depthEnd);
            firstIteration = false;
        } else {
            nextSupersegmentInList(theList, exit_distance, dotPositive, supseg_found, index, depthStart, depthEnd);
        }

        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("For list: (%d, %d). Found supseg %d index %d. Start depth: %f and end depth: %f\n", theList, supseg_found, index, depthStart, depthEnd);
        }
        #endif
        prevList = theList;

        prevIndex = index; //setting prevIndex even if no supersegment was found

        if(dotPositive) {
            depthStart = max(dist_to_orig, depthStart);
            depthEnd = min(exit_distance, depthEnd);
        } else {
            depthStart = min(dist_to_orig, depthStart);
            depthEnd = max(exit_distance, depthEnd);
        }

        if(supseg_found) {
            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Found supseg: (%d, %d), %d\n", theList, index);
            }
            #endif

            #if INT_DEPTHS
            depthStart = w_to_ndc(depthStart); //if the distances were calculated in w space, we need to convert to a coordinate system that has constant value of z along the supseg face, which makes it easy to detrmine where exactly the ray has intersected the supseg
            depthEnd = w_to_ndc(depthEnd);
            #endif

            float start_t = (depthStart - u.z) / dir.z;
            float end_t = (depthEnd - u.z) / dir.z;

            if(dotPositive)
            {start_point = u + dir * start_t;
                end_point = u + dir * end_t;}
            vec4 w_start_point = ivp_orig * start_point;
            w_start_point *= 1./w_start_point.w;

            vec4 w_end_point = ivp_orig * end_point;
            w_end_point *= 1./w_end_point.w;

            vec4 supseg_col;
            #if DOUBLE_BUFFER
            supseg_col = GET_SUPERSEGMENT_COLOR(theList, index, useSecondBuffer);
            #else
            supseg_col = GET_SUPERSEGMENT_COLOR(theList, index, false);
            #endif

            float length_in_supseg = distance(w_start_point, w_end_point);

            float alpha = adjustOpacity(supseg_col.a, length_in_supseg);

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Accumulated color: (%f, %f, %f, %f)", accumulatedColor.rgba);
            }
            #endif

            accumulatedColor.rgb = accumulatedColor.rgb + (1-accumulatedColor.a) * supseg_col.rgb * alpha;
            accumulatedColor.a = accumulatedColor.a + (1-accumulatedColor.a) * alpha;

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("supsegCol: (%f, %f, %f, %f), alpha: %f", supseg_col.xyzw, alpha);
                debugPrintfEXT("NDC start point: (%f, %f, %f, %f) and NDC end point: (%f, %f, %f, %f).", start_point.xyzw, end_point.xyzw);
                debugPrintfEXT("World start point: (%f, %f, %f, %f) and end point: (%f, %f, %f, %f). Length: %f", w_start_point.xyzw, w_end_point.xyzw, length_in_supseg);
                debugPrintfEXT("Accumulated color: (%f, %f, %f, %f)", accumulatedColor.rgba);
            }
            #endif

            if(accumulatedColor.a > 0.99) {
                break;
            }
        }
    } while(supseg_found);
}

int stepX, stepY;
float tdeltaX, tdeltaY; //the delta intercepts for the ray on the supseg lists
vec4 finalColor = vec4(0);

void traverse_subsample(vec4 world_entry, vec4 world_end, float total_distance, int num_samples) {

    float jump_size = total_distance / float(num_samples);

    float step = 0;

    float normalized_jump = jump_size / total_distance;

    for(int i = 1; i <= num_samples; i++) {
        step = (normalized_jump +  ((i - 1) * normalized_jump));
        vec4 wpos = mix(world_entry, world_end, step);

        vec4 npos = pv_orig * wpos;
        npos *= 1. / npos.w;
        vec2 tex = (npos.xy + 1) / 2.0;

        ivec2 list_coords;
        list_coords.x = int(round(tex.x * vdiWidth));
        list_coords.y = int(round(tex.y * vdiHeight));

        originalRay.coords = list_coords;
        originalRay.NDC_front = vec4( npos.xy, -1, 1 );
        originalRay.NDC_back = vec4( npos.xy, 1, 1 );

        originalRay.wfront = ivp_orig * originalRay.NDC_front;
        originalRay.wfront *= 1.0 / originalRay.wfront.w;

        originalRay.wback = ivp_orig * originalRay.NDC_back;
        originalRay.wback *= 1.0 / originalRay.wback.w;

        // -- bounding box intersection for all volumes ----------
        orig_tnear = 1, orig_tfar = 0;
        float n, f;

        bool vis = false;
        intersectBoundingBox_x_11_x_( originalRay.wfront, originalRay.wback, n, f );

        if ( n < f )
        {
            orig_tnear = min( orig_tnear, max( 0, n ) );
            orig_tfar = max( orig_tfar, f );
            vis = true;
        }

        bool supseg_found;
        int index;
        float depth_start, depth_end;

        #if INT_DEPTHS
        float dist_to_orig = ndc_to_w(npos.xy, npos.z);
        #else
        float dist_to_orig = npos.z;
        #endif

        findFirstSupseg(list_coords, dist_to_orig, dist_to_orig, supseg_found, index, depth_start, depth_end);

        if(supseg_found) {

            #if INT_DEPTHS
            depth_start = w_to_ndc(depth_start);
            depth_end = w_to_ndc(depth_end);
            #endif

            vec4 supseg_start_w = ivp_orig * vec4(npos.xy, depth_start, 1);
            supseg_start_w *= 1. / supseg_start_w.w;

            vec4 supseg_end_w = ivp_orig * vec4(npos.xy, depth_end, 1);
            supseg_end_w *= 1. / supseg_end_w.w;


            vec4 supseg_col;
            #if DOUBLE_BUFFER
            supseg_col = GET_SUPERSEGMENT_COLOR(list_coords, index, useSecondBuffer);
            #else
            supseg_col = GET_SUPERSEGMENT_COLOR(list_coords, index, useSecondBuffer);
            #endif

            float alpha = adjustOpacity(supseg_col.a, jump_size);
            finalColor.rgb = finalColor.rgb + (1-finalColor.a) * supseg_col.rgb * alpha;
            finalColor.a = finalColor.a + (1-finalColor.a) * alpha;
        }
    }
}

void traverse_cell(vec4 entry_point, ivec2 entry_list, vec3 cell_min, vec3 cell_max, out vec4 end_point, out ivec2 nextList) {

    const float max_x = max(cell_max.x, cell_min.x);
    const float min_x = min(cell_max.x, cell_min.x);
    const float max_y = max(cell_max.y, cell_min.y);
    const float min_y = min(cell_max.y, cell_min.y);

    float nextX = entry_list.x + stepX * 0.5;
    float nextY = entry_list.y + stepY * 0.5;

    float finalZ = dir.z > 0 ? cell_max.z : cell_min.z; //TODO: Should this be 0 instead of -1

    float nextX_ndc = nextX / vdiWidth * 2.0 - 1.0;
    float nextY_ndc = nextY / vdiHeight * 2.0 - 1.0;

    float tmaxX = dir.x != 0 ? abs((nextX_ndc - entry_point.x) / dir.x) : 10000000;
    float tmaxY = dir.y != 0 ? abs((nextY_ndc - entry_point.y) / dir.y) : 10000000;
    float tmaxZ = dir.z != 0 ? abs((finalZ - entry_point.z) / dir.z) : 10000000;

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("tmaxX: %f, tmaxY: %f, tmaxZ: %f\n", tmaxX, tmaxY, tmaxZ);
    }
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Dirx: %f, diry: %f, dirz: %f\n", dir.x, dir.y, dir.z);
    }
        #endif
    ivec2 currentList = entry_list;
    nextList = currentList;
    vec4 start_point = entry_point;

    bool finalIteration = false;

    while ( !finalIteration ) // loop over all the lists intersected by this ray
    {
        #if USE_PRINTF
        if(gl_GlobalInvocationID.xy == debug_pixel) {
            debugPrintfEXT("Looping for list: (%d, %d)\n", currentList);
        }
            #endif
        float incr = 0;
        if(tmaxZ <= tmaxX && tmaxZ <= tmaxY) {
            //z is lowest
            /* this check only ensures that this list will be the last one intersected in this cell. For calculating the
             end point in the list, and the next_list, we use the x or y intercept*/

            finalIteration = true;
        }
        if(tmaxX < tmaxY) {
            //x is the lowest
            incr = tmaxX;
            nextList.x += stepX;
            tmaxX += tdeltaX;
        } else if(tmaxY < tmaxX) {
            //y is the lowest
            incr = tmaxY;
            nextList.y += stepY;
            tmaxY += tdeltaY;
        } else {
            // x and y are equal
            incr = tmaxX;
            nextList.x += stepX;
            nextList.y += stepY;
            tmaxX += tdeltaX;
            tmaxY += tdeltaY;
        }

        end_point = entry_point + dir * incr;
        bool terminate = false;

        if(stepX == 1) {
            if(end_point.x > max_x) { //TODO: perhaps a delta needs to be added to the comparison
                terminate = true;
            }
        } else {
            if(end_point.x < min_x) { //TODO: this check can potentially be incorporated into the loop
                terminate = true;
            }
        }

        if(stepY == 1) {
            if(end_point.y > max_y) {
                terminate = true;
            }
        } else {
            if(end_point.y < min_y) {
                terminate = true;
            }
        }
        findSupsegsInList(currentList, start_point, end_point, finalColor);

        if(terminate) {
            break;
        }
        if(finalColor.a > 0.99) {
            break;
        }
        currentList = nextList;
        start_point = end_point;
    }
}

float cellToViewToNDC(int cell_z) {
    float dist_from_near = cell_z * ((far_plane - near_plane) / float(num_cells.z));
    float view_z = dist_from_near + near_plane;
    view_z = -1 * view_z;

    float ndc_z = -1 * ((A * view_z + B) / view_z);

    return ndc_z;
}

ivec3 findGridCell(vec4 position) {
    ivec3 grid_coords;

    vec2 tex = (position.xy + vec2(1.)) / 2.;

    grid_coords.xy = ivec2(floor(tex * num_cells.xy));
    grid_coords.z = findZInterval_view(position.z);

    return grid_coords;
}

void main() {

    ivec2 imageCoords  = imageSize(OutputViewport);

    if(skip_empty) {
        #if DOUBLE_BUFFER
        if(useSecondBuffer){
            num_cells = imageSize(AccelerationGrid2).xyz;
        } else {
            num_cells = imageSize(AccelerationGrid).xyz;
        }
        #else
        num_cells = imageSize(AccelerationGrid).xyz;
        #endif
    } else {
        num_cells = ivec3(1);
    }

    windowWidth = imageCoords.x;
    windowHeight = imageCoords.y;
    windowWidth = int(downImage * windowWidth);
    windowHeight = int(downImage * windowHeight);

    ivec3 vdiCoords;
    #if DOUBLE_BUFFER
    maxSupersegments = getNumberOfSupersegments(useSecondBuffer);
    #else
    maxSupersegments = getNumberOfSupersegments(false);
    #endif

    mat4 view;

    view = (vrParameters.stereoEnabled ^ 1) * ViewMatrices[0] + (vrParameters.stereoEnabled * ViewMatrices[currentEye.eye]);

    mat4 inverseProjection = (vrParameters.stereoEnabled ^ 1) * InverseProjectionMatrix + (vrParameters.stereoEnabled * vrParameters.inverseProjectionMatrices[currentEye.eye]);
    mat4 inverseView = inverse(view); //TODO: Why not use InverseViewMatrices[] directly?

    highp mat4 ipv = inverseView * inverseProjection;

        mat4 matViewOrig;
    #if DOUBLE_BUFFER
    if(useSecondBuffer) {
        matViewOrig = ViewOriginal2;
    } else {
        matViewOrig = ViewOriginal;
    }
    #else
    matViewOrig = ViewOriginal;
    #endif

    mat4 matInvViewOrig;
    #if DOUBLE_BUFFER
    if(useSecondBuffer) {
        matInvViewOrig = invViewOriginal2;
    } else {
        matInvViewOrig = invViewOriginal;
    }
    #else
    matInvViewOrig = invViewOriginal;
    #endif

    pv_orig = ProjectionOriginal * matViewOrig;
    ivp_orig = matInvViewOrig * invProjectionOriginal;

    vec2 texcoord = gl_GlobalInvocationID.xy/vec2(windowWidth, windowHeight); //TODO: here the ww and wh need to remain as they are
    if((texcoord.x > 1) || (texcoord.y > 1)) {
        return;
    }
    vec2 uv = texcoord * 2.0 - vec2(1.0);
    vec2 depthUV = (vrParameters.stereoEnabled ^ 1) * texcoord + vrParameters.stereoEnabled * vec2((texcoord.x/2.0 + currentEye.eye * 0.5), texcoord.y);
    depthUV = depthUV * 2.0 - vec2(1.0);
    newRay.coords.xy = ivec2(gl_GlobalInvocationID.xy);
    // NDC of frag on near and far plane
    newRay.NDC_front = vec4( uv, -1, 1 );
    newRay.NDC_back = vec4( uv, 1, 1 );
    // calculate eye ray in world space
    newRay.wfront = ipv * newRay.NDC_front;
    newRay.wfront *= 1.0 / newRay.wfront.w;
    newRay.wback = ipv * newRay.NDC_back;
    newRay.wback *= 1 / newRay.wback.w;

    front_orig = pv_orig * newRay.wfront; // start point of ray in NDC coordinates of original viewpoint
    front_orig *= 1.0 / front_orig.w;
    back_orig = pv_orig * newRay.wback; // end point of ray in NDC coordinates of original viewpoint
    back_orig *= 1.0 / back_orig.w;

    // -- bounding box intersection for all volumes ----------
    float tnear = 1, tfar = 0, tmax = 0; //getMaxDepth( depthUV );
    float n, f;

    bool vis = false;
    intersectBoundingBox_x_11_x_( newRay.wfront, newRay.wback, n, f );
    //    f = min( tmax, f );
    if ( n < f )
    {
        tnear = min( tnear, max( 0, n ) );
        tfar = max( tfar, f );
        vis = true;
    }
    if(!vis) {
        imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(0));
        return;
    }

    float step = tnear;

    vec4 first_entry_pt, final_exit_pt;

    int cnt = 0;
    ivec2 firstList;

    if(tnear > tfar) {
        finalColor = vec4(0, 0, 0, 1);
        return;
    } else {
        // calculate the value of an acceptable small step
        //calculate min width of a supseg list in NDC
        vec4 n_start = vec4(0, 0, 0, 1);
        vec4 n_end = vec4((2. / max(vdiHeight, vdiWidth)), 0, 0, 1);

        vec4 w_start = ivp_orig * n_start;
        w_start = w_start / w_start.w;

        vec4 w_end = ivp_orig * n_end;
        w_end = w_end / w_end.w;

        vec4 view_orig = ViewOriginal * newRay.wfront;

        view_orig = view_orig / view_orig.w;

        // find the first supersegment

        vec4 wnear = mix(newRay.wfront, newRay.wback, tnear);

        //if this point is within original viewport, then this is the starting point for raycasting
        //if not, we need to find the first point in this direction that is in the original viewport
        vec4 ndc_near = pv_orig * wnear;
        ndc_near *= 1. / ndc_near.w;
        first_entry_pt = ndc_near;

        vec4 wfar = mix(newRay.wfront, newRay.wback, tfar);

        vec4 ndc_far = pv_orig * wfar;
        ndc_far *= 1. / ndc_far.w;
        final_exit_pt = ndc_far;
        float eps = 0.0001;
        vec3 rayDirection = (ndc_far - ndc_near).xyz;

        //TODO: is there a better way to do this?
        if(rayDirection.x == 0) {
            rayDirection.x = 0.000001;
        } else if(rayDirection.y == 0) {
            rayDirection.y = 0.000001;
        } else if (rayDirection.z == 0) {
            rayDirection.z = 0.000001;
        }

        rayDirection = normalize(rayDirection);

        dir.xyz = rayDirection;
        dir.w = 0;


        if(ndc_near.x < -1 || ndc_near.x > 1 || ndc_near.y < -1 || ndc_near.y > 1 || ndc_near.z < -1 || ndc_near.z > 1) {
            // the point is not in the original viewport
            float d1, d2;

            // intersect the NDC frustum of the original viewpoint
            intersectBox( ndc_near.xyz, rayDirection, vec3(-1.), vec3(1.), d1, d2);

            if(d1 > d2) {
                //an error has occurred. This ray either doesn't pass through the original viewport or
                // passes right at the edge, and floating point error is making the alg. believe it misses

                imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(0));
                return;
            }

            vec4 f_pt = vec4(ndc_near.xyz + rayDirection * d1, 1);
            vec4 l_pt = vec4(ndc_near.xyz + rayDirection * d2, 1);

            vec4 f_pt_w = ivp_orig * f_pt;
            f_pt_w *= 1. / f_pt_w.w;
            vec4 l_pt_w = ivp_orig * l_pt;
            l_pt_w *= 1. / l_pt_w.w;

            if(distance(f_pt_w, newRay.wfront) > distance(l_pt_w, newRay.wfront)) {
                step = distance(l_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (l_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * vdiWidth));
                firstList.y = int(round(tex_orig.y * vdiHeight));

                first_entry_pt = l_pt;
                final_exit_pt = f_pt;
            } else {
                step = distance(f_pt_w, newRay.wfront) / distance(newRay.wfront, newRay.wback);
                vec2 tex_orig = (f_pt.xy + 1) / 2.0;

                firstList.x = int(round(tex_orig.x * vdiWidth));
                firstList.y = int(round(tex_orig.y * vdiHeight));

                first_entry_pt = f_pt;
                final_exit_pt = l_pt;
            }

        } else {
            vec4 ndc;
            findListNumber(wnear, firstList, ndc);
            step = tnear;
        }

        front_orig = first_entry_pt;
        back_orig = final_exit_pt;

    }

    ivec2 currentList = firstList;
    u = first_entry_pt;

    stepX = dir.x > 0 ? 1 : -1;
    stepY = dir.y > 0 ? 1 : -1;
    int stepZ = dir.z > 0 ? 1 : -1;

    tdeltaX = abs((2.0 / vdiWidth) / dir.x);
    tdeltaY = abs((2.0 / vdiHeight) / dir.y);

    const int MAX_X = 1;
    const int MIN_X = -1;

    const int MAX_Y = 1;
    const int MIN_Y = -1;

    const int MAX_Z = 1;
    const int MIN_Z = -1;

    float cell_tdeltaX = abs((2. / num_cells.x) / dir.x);
    float cell_tdeltaY = abs((2. / num_cells.y) / dir.y);
    float cell_tdeltaZ = 0;

    vec4 end_point = vec4(0);
    vec4 start_point = vec4(0);
    vec4 end_traversal = vec4(0);
    ivec2 start_list, next_list;
    ivec3 grid_cell, next_cell;
    float cell_tmaxX, cell_tmaxY, cell_tmaxZ;
    bool finalIteration = false;

    int num_traversed = 0;

    int num_octree_traversals = 1;
    if(do_subsample) {
        num_octree_traversals = 2;
    }
    float length_in_non_empty = 0;

    int calculatedMaxSteps = 0;

    for(int trav = 1; trav <= num_octree_traversals; trav++) {

        start_point = first_entry_pt;

        vec2 tex_orig = (start_point.xy + 1.0) / 2.0;

        start_list.x = int(round(tex_orig.x * vdiWidth));
        start_list.y = int(round(tex_orig.y * vdiHeight));

        next_list = start_list;

        //    ivec3 grid_cell = findGridCell(start_list, start_point.z);
        grid_cell = findGridCell(start_point);
        next_cell = grid_cell;
        next_cell.x += (stepX == 1 ? 1 : 0);
        next_cell.y += (stepY == 1 ? 1 : 0);
        next_cell.z += (stepZ == 1 ? 1 : 0);

        vec3 next_cell_ndc;
        next_cell_ndc.xy = ((next_cell.xy / vec2(num_cells.xy)) * 2.0) - vec2(1.0);
        next_cell_ndc.z = cellToViewToNDC(next_cell.z);

        //        cell_tmaxX = dir.x != 0 ? abs((next_cell_ndc.x - start_point.x) / dir.x) : 10000000;
        //        cell_tmaxY = dir.y != 0 ? abs((next_cell_ndc.y - start_point.y) / dir.y) : 10000000;
        //        cell_tmaxZ = dir.z != 0 ? abs((next_cell_ndc.z - start_point.z) / dir.z) : 10000000;

        cell_tmaxX = abs((next_cell_ndc.x - start_point.x) / dir.x);
        cell_tmaxY = abs((next_cell_ndc.y - start_point.y) / dir.y);
        cell_tmaxZ = abs((next_cell_ndc.z - start_point.z) / dir.z);

        float t = 0;
        end_traversal = vec4(0);

        finalIteration = false;
        bool cell_traversed = false;

        while(!finalIteration) { //looping over the cells of the lowest level of the octree

            if(cell_traversed) {
                //if the new cell is to start at the end point of the previous traversal, then we need to check whether the
                //previous traversal took us to a different grid cell along z

                //            ivec3 grid_at_end = findGridCell(start_list, start_point.z);
                if(start_point.x < MIN_X || start_point.x > MAX_X || start_point.y < MIN_Y || start_point.y > MAX_Y || start_point.z < MIN_Z || start_point.z > MAX_Z) {
                    break;
                }

                ivec3 grid_at_end = findGridCell(start_point);

                if(grid_at_end.x != grid_cell.x) {
                    t = cell_tmaxX;
                    cell_tmaxX += cell_tdeltaX;
                }

                if(grid_at_end.y != grid_cell.y) {
                    t = cell_tmaxY;
                    cell_tmaxY += cell_tdeltaY;
                }

                if(grid_at_end.z != grid_cell.z) {
                    t = cell_tmaxZ;
                    float current_z_ndc = cellToViewToNDC(grid_at_end.z);
                    int next_z = grid_at_end.z + (stepZ == 1 ? 1 : -1);
                    float next_z_ndc = cellToViewToNDC(next_z);
                    cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("current z: %d, next z: %d, delta obtained: %f, prev tmaxZ was: %f", grid_cell.z, grid_at_end.z, cell_tdeltaZ, cell_tmaxZ);
                    }
                    #endif
                    cell_tmaxZ += cell_tdeltaZ;
                }


                grid_cell = grid_at_end;


            }

            cell_traversed = false;

            vec3 cell_min;
            cell_min.xy = vec2(grid_cell.xy / vec2(num_cells.xy));
            cell_min.xy = (cell_min.xy * 2.) - 1.;
            cell_min.z = cellToViewToNDC(grid_cell.z);
            vec3 cell_max;
            cell_max.xy = vec2((grid_cell.xy+vec2(1.)) / vec2(num_cells.xy));
            cell_max.xy = (cell_max.xy * 2.) - 1.;
            cell_max.z = cellToViewToNDC(grid_cell.z + 1);

            uint grid_val;

            if(skip_empty) {
                #if DOUBLE_BUFFER
                if(useSecondBuffer) {
                    grid_val = imageLoad(AccelerationGrid2, grid_cell).r;
                } else {
                    grid_val = imageLoad(AccelerationGrid, grid_cell).r;
                }
                #else
                grid_val = imageLoad(AccelerationGrid, grid_cell).r;
                #endif
            } else {
                grid_val = 1;
            }

            #if USE_PRINTF
            if(gl_GlobalInvocationID.xy == debug_pixel) {
                debugPrintfEXT("Checking the cell: (%d, %d, %d). value: %d", grid_cell.xyz, grid_val);
            }
            #endif

            if(grid_val > 0 && !do_subsample) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("traversing the cell: (%d, %d, %d), cell min: (%f, %f, %f), cell max: (%f, %f, %f), start point: (%f, %f, %f). value: %d\n", grid_cell.xyz, cell_min.xyz, cell_max.xyz, start_point.xyz, grid_val);
                }
                #endif

                traverse_cell(start_point, start_list, cell_min, cell_max, end_traversal, next_list);
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("end point: (%f, %f, %f)", end_point.xyz);
                }
                    #endif
                cell_traversed = true;
            }

            //TODO: the next section can probably be skipped if the cell has been traversed

            // changed this from always true to !cell_traversed
            if(!cell_traversed) {

                #if USE_PRINTF
                if (gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("cell_tmaxX: %f, cell_tmaxY: %f, cell_tmaxZ: %f\n", cell_tmaxX, cell_tmaxY, cell_tmaxZ);
                }
                    #endif


                if(cell_tmaxX < cell_tmaxY) {
                    if(cell_tmaxX < cell_tmaxZ) {
                        // x is the lowest
                        t = cell_tmaxX;
                        grid_cell.x += stepX;
                        if(grid_cell.x >= num_cells.x || grid_cell.x < 0) { // TODO: only one comparison is required depending on stepX
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new x val: %d:", grid_cell.x);
                            }
                                #endif
                        }
                        cell_tmaxX += cell_tdeltaX;
                    } else {
                        // z is lowest or x = z
                        t = cell_tmaxZ;
                        grid_cell.z += stepZ;
                        if(grid_cell.z >= num_cells.z || grid_cell.z < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                            }
                                #endif
                        }

                        int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                        float current_z_ndc = cellToViewToNDC(grid_cell.z);
                        float next_z_ndc = cellToViewToNDC(next_z);
                        cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;

                        cell_tmaxZ += cell_tdeltaZ;
                    }
                } else {
                    if(cell_tmaxY < cell_tmaxZ) {
                        // y is the lowest
                        t = cell_tmaxY;
                        grid_cell.y += stepY;
                        if(grid_cell.y >= num_cells.y || grid_cell.y < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new y val: %d:", grid_cell.y);
                            }
                                #endif
                        }
                        cell_tmaxY += cell_tdeltaY;
                    } else {
                        // z is the lowest or y = z
                        t = cell_tmaxZ;
                        grid_cell.z += stepZ;
                        if(grid_cell.z >= num_cells.z || grid_cell.z < 0) {
                            finalIteration = true;
                            #if USE_PRINTF
                            if(gl_GlobalInvocationID.xy == debug_pixel) {
                                debugPrintfEXT("This is final iteration because new z val: %d:", grid_cell.z);
                            }
                                #endif
                        }

                        int next_z = grid_cell.z + (stepZ == 1 ? 1 : -1);
                        float current_z_ndc = cellToViewToNDC(grid_cell.z);
                        float next_z_ndc = cellToViewToNDC(next_z);
                        cell_tdeltaZ = dir.z != 0 ? abs((next_z_ndc - current_z_ndc) / dir.z) : 10000000;

                        cell_tmaxZ += cell_tdeltaZ;
                    }
                }

                end_point = first_entry_pt + t * dir;
                tex_orig = (end_point.xy + 1.0)/2.0;

                next_list.x = int(round(tex_orig.x * vdiWidth));
                next_list.y = int(round(tex_orig.y * vdiHeight));
            } else {
                end_point = end_traversal;
                //we have next_list from the traversal method
            }

            uint supsegs_in_cell;
            if(skip_empty) {
                supsegs_in_cell = imageLoad(AccelerationGrid, grid_cell).r;
            } else {
                supsegs_in_cell = 0;
            }

            if(supsegs_in_cell > 0 && do_subsample) {
                vec4 cell_start_w = ivp_orig * start_point;
                cell_start_w *= 1. / cell_start_w.w;

                vec4 cell_end_w = ivp_orig * end_point;
                cell_end_w *= 1. / cell_end_w.w;
                float intersection_length = distance(cell_start_w, cell_end_w);
                if(trav == 1) {
                    length_in_non_empty += supsegs_in_cell * intersection_length;
                } else {
                    float fract =  (supsegs_in_cell * intersection_length) / length_in_non_empty;
                    //                    int samples_in_cell = int(fract * max_samples); //TODO: should it be round()?
                    int samples_in_cell = int(fract * calculatedMaxSteps); //TODO: should it be round()?
                    #if USE_PRINTF
                    if(gl_GlobalInvocationID.xy == debug_pixel) {
                        debugPrintfEXT("Cell: (%d, %d, %d), intersection length: %f and supseg count: %d. Steps: %d will be taken. Max samples: %d and overall length_in_non_empty: %f calculated max steps: %d", grid_cell.xyz, intersection_length,
                        int(supsegs_in_cell), samples_in_cell, max_samples, length_in_non_empty, calculatedMaxSteps);
                    }
                    #endif

                    traverse_subsample(cell_start_w, cell_end_w, intersection_length, samples_in_cell);
                    num_traversed++;
                }
            }


            //TODO: add check for outside the volume even though still inside the VDI

            if(finalColor.a > 0.99) {
                #if USE_PRINTF
                if(gl_GlobalInvocationID.xy == debug_pixel) {
                    debugPrintfEXT("Breaking because alpha is: %f", finalColor.a);
                }
                #endif
                break;
            }

            start_point = end_point;
            start_list = next_list;
        }
        calculatedMaxSteps = int(length_in_non_empty * sampling_factor);
    }

    finalColor.xyz = pow(finalColor.xyz, vec3(1/2.2));

    imageStore(OutputViewport, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), finalColor);

    #if USE_PRINTF
    if(gl_GlobalInvocationID.xy == debug_pixel) {
        debugPrintfEXT("Final!!! composited color is: (%f, %f, %f, %f)", finalColor.rgba);
    }
    #endif
}
