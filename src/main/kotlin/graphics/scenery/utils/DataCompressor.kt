package graphics.scenery.utils

import org.xerial.snappy.Snappy
import java.nio.ByteBuffer
import org.lwjgl.util.zstd.Zstd.*
import org.lwjgl.util.zstd.ZstdX.ZSTD_findDecompressedSize
import org.lwjgl.util.lz4.LZ4.*
import org.lwjgl.util.lz4.LZ4Frame.LZ4F_getErrorName
import org.lwjgl.util.lz4.LZ4Frame.LZ4F_isError

/**
 * Lossless compression and decompression of binary data. Currently, the [CompressionTool]
 * supported are Snappy, LZ4 and ZSTD
 *
 * @author Aryaman Gupta <argupta@mpi-cbg.de>
 */

class DataCompressor (val compressionTool: CompressionTool) {

    val logger by lazyLogger()

    /**
     * The tool used for compression
     */
    enum class CompressionTool {
        ZSTD,
        LZ4,
        Snappy
    }

    private fun compressSnappy(compressed: ByteBuffer, uncompressed: ByteBuffer): Long {
        return Snappy.compress(uncompressed, compressed).toLong()
    }

    private fun decompressSnappy(decompressed: ByteBuffer, compressed: ByteBuffer): Long {
        return Snappy.uncompress(compressed, decompressed).toLong()
    }

    private fun compressZSTD(compressed: ByteBuffer, uncompressed: ByteBuffer, level: Int): Long {
        return checkZSTD(ZSTD_compress(compressed, uncompressed, level))
    }

    private fun decompressZSTD(decompressed: ByteBuffer, compressed: ByteBuffer): Long {
        checkZSTD(ZSTD_findDecompressedSize(compressed))
        return ZSTD_decompress(decompressed, compressed)
    }

    private fun compressLZ4(compressed: ByteBuffer, uncompressed: ByteBuffer, level: Int): Long {
        return checkLZ4F(LZ4_compress_fast(uncompressed, compressed, level).toLong())
    }

    private fun decompressLZ4(decompressed: ByteBuffer, compressed: ByteBuffer): Long {
        return checkLZ4F(LZ4_decompress_safe(compressed, decompressed).toLong())
    }

    private fun checkZSTD(errorCode: Long): Long {
        check(!ZSTD_isError(errorCode)) { "Zstd error: " + errorCode + " | " + ZSTD_getErrorName(errorCode) }
        return errorCode
    }

    private fun checkLZ4F(errorCode: Long): Long {
        check(!LZ4F_isError(errorCode)) { "LZ4 error: " + errorCode + " | " + LZ4F_getErrorName(errorCode) }
        return errorCode
    }

    /**
     * Returns the maximum size of the compressed buffer generated by the selected [CompressionTool], for
     * a source buffer of size [sourceSize].
     */
    fun returnCompressBound(sourceSize: Long): Int {
        return when (compressionTool) {
            CompressionTool.ZSTD -> {
                ZSTD_COMPRESSBOUND(sourceSize).toInt()
            }
            CompressionTool.LZ4 -> {
                LZ4_compressBound(sourceSize.toInt())
            }
            CompressionTool.Snappy -> {
                Snappy.maxCompressedLength(sourceSize.toInt())
            }
        }
    }

    /**
     * Compares buffers [uncompressed] and [decompressed] byte-by-byte. If the [decompressed] buffer
     * is a result of a compression followed by decompression of the [uncompressed] buffer, this
     * amounts to a verification of the compression and decompression functionalities.
     *
     * Returns true if the two buffers are identical, otherwise false.
     */
    fun verifyDecompressed(uncompressed: ByteBuffer, decompressed: ByteBuffer): Boolean {
        var verificationSuccessful = true

        val decompressedSize = decompressed.remaining().toLong()
        if(decompressedSize != uncompressed.remaining().toLong()) {
            verificationSuccessful = false
            logger.info(
                "Decompressed size {} != uncompressed size {}",
                decompressedSize,
                uncompressed.remaining()
            )
        }

        for (i in 0 until uncompressed.remaining()) {
            if(decompressed[i] != uncompressed[i]) {
                verificationSuccessful = false
                logger.debug("Decompressed != uncompressed at: $i")
            }
        }

        return verificationSuccessful
    }

    /**
     * Compress buffer using tool [compressionTool]
     *
     * @param[uncompressed] the buffer to be compressed
     * @param[compressed] the buffer the compressed result is stored in
     * @param[level] for ZSTD and LZ4, the desired level of compression. For LZ4, higher values lead to faster, but less
     * compression, while for ZSTD, the opposite is true. Optional parameter.
     *
     * Returns the length (in bytes) of the compressed buffer
     */
    fun compress(compressed: ByteBuffer, uncompressed: ByteBuffer, level: Int? = null): Long {
        val compressionLevel = level
            ?: 0

        return when (compressionTool) {
            CompressionTool.ZSTD -> {
                compressZSTD(compressed, uncompressed, compressionLevel)
            }
            CompressionTool.LZ4 -> {
                compressLZ4(compressed, uncompressed, compressionLevel)
            }
            CompressionTool.Snappy -> {
                compressSnappy(compressed, uncompressed)
            }
        }
    }

    /**
     * Decompress buffer compressed using tool [compressionTool]
     *
     * @param[compressed] the buffer to be compressed
     * @param[decompressed] the buffer the decompressed result is stored in
     */
    fun decompress(decompressed: ByteBuffer, compressed: ByteBuffer): Long {
        return when (compressionTool) {
            CompressionTool.ZSTD -> {
                decompressZSTD(decompressed, compressed)
            }
            CompressionTool.LZ4 -> {
                decompressLZ4(decompressed, compressed)
            }
            CompressionTool.Snappy -> {
                decompressSnappy(decompressed, compressed)
            }
        }
    }
}
